// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addPaidCredits = `-- name: AddPaidCredits :one
UPDATE user_credits
SET paid_credits = paid_credits + $2, updated_at = NOW()
WHERE user_id = $1
RETURNING id, user_id, free_generations_used, free_generations_limit, created_at, updated_at, paid_credits, total_generations
`

type AddPaidCreditsParams struct {
	UserID      string `json:"user_id"`
	PaidCredits int32  `json:"paid_credits"`
}

// Add purchased credits to user's balance
func (q *Queries) AddPaidCredits(ctx context.Context, arg AddPaidCreditsParams) (UserCredit, error) {
	row := q.db.QueryRow(ctx, addPaidCredits, arg.UserID, arg.PaidCredits)
	var i UserCredit
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FreeGenerationsUsed,
		&i.FreeGenerationsLimit,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PaidCredits,
		&i.TotalGenerations,
	)
	return i, err
}

const countCVsByUser = `-- name: CountCVsByUser :one
SELECT COUNT(*) FROM generated_cvs WHERE user_id = $1
`

func (q *Queries) CountCVsByUser(ctx context.Context, userID string) (int64, error) {
	row := q.db.QueryRow(ctx, countCVsByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createCV = `-- name: CreateCV :one
INSERT INTO generated_cvs (
    user_id, name, job_url, job_title, company_name, 
    job_description, cv_data, match_score, ai_suggestions, template_id
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
RETURNING id, user_id, name, job_url, job_title, company_name, job_description, cv_data, match_score, ai_suggestions, template_id, created_at, updated_at
`

type CreateCVParams struct {
	UserID         string      `json:"user_id"`
	Name           string      `json:"name"`
	JobUrl         pgtype.Text `json:"job_url"`
	JobTitle       pgtype.Text `json:"job_title"`
	CompanyName    pgtype.Text `json:"company_name"`
	JobDescription pgtype.Text `json:"job_description"`
	CvData         []byte      `json:"cv_data"`
	MatchScore     pgtype.Int4 `json:"match_score"`
	AiSuggestions  []byte      `json:"ai_suggestions"`
	TemplateID     pgtype.Text `json:"template_id"`
}

func (q *Queries) CreateCV(ctx context.Context, arg CreateCVParams) (GeneratedCv, error) {
	row := q.db.QueryRow(ctx, createCV,
		arg.UserID,
		arg.Name,
		arg.JobUrl,
		arg.JobTitle,
		arg.CompanyName,
		arg.JobDescription,
		arg.CvData,
		arg.MatchScore,
		arg.AiSuggestions,
		arg.TemplateID,
	)
	var i GeneratedCv
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.JobUrl,
		&i.JobTitle,
		&i.CompanyName,
		&i.JobDescription,
		&i.CvData,
		&i.MatchScore,
		&i.AiSuggestions,
		&i.TemplateID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createCoverLetter = `-- name: CreateCoverLetter :one
INSERT INTO cover_letters (user_id, cv_id, content, job_title, company_name)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, user_id, cv_id, content, job_title, company_name, created_at, updated_at
`

type CreateCoverLetterParams struct {
	UserID      string      `json:"user_id"`
	CvID        pgtype.UUID `json:"cv_id"`
	Content     string      `json:"content"`
	JobTitle    pgtype.Text `json:"job_title"`
	CompanyName pgtype.Text `json:"company_name"`
}

func (q *Queries) CreateCoverLetter(ctx context.Context, arg CreateCoverLetterParams) (CoverLetter, error) {
	row := q.db.QueryRow(ctx, createCoverLetter,
		arg.UserID,
		arg.CvID,
		arg.Content,
		arg.JobTitle,
		arg.CompanyName,
	)
	var i CoverLetter
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CvID,
		&i.Content,
		&i.JobTitle,
		&i.CompanyName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createMasterProfile = `-- name: CreateMasterProfile :one
INSERT INTO master_profiles (user_id, resume_data)
VALUES ($1, $2)
RETURNING id, user_id, resume_data, created_at, updated_at
`

type CreateMasterProfileParams struct {
	UserID     string `json:"user_id"`
	ResumeData []byte `json:"resume_data"`
}

func (q *Queries) CreateMasterProfile(ctx context.Context, arg CreateMasterProfileParams) (MasterProfile, error) {
	row := q.db.QueryRow(ctx, createMasterProfile, arg.UserID, arg.ResumeData)
	var i MasterProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ResumeData,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUserCredits = `-- name: CreateUserCredits :one
INSERT INTO user_credits (user_id, free_generations_used, free_generations_limit, paid_credits, total_generations)
VALUES ($1, 0, 10, 0, 0)
RETURNING id, user_id, free_generations_used, free_generations_limit, created_at, updated_at, paid_credits, total_generations
`

func (q *Queries) CreateUserCredits(ctx context.Context, userID string) (UserCredit, error) {
	row := q.db.QueryRow(ctx, createUserCredits, userID)
	var i UserCredit
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FreeGenerationsUsed,
		&i.FreeGenerationsLimit,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PaidCredits,
		&i.TotalGenerations,
	)
	return i, err
}

const deleteCV = `-- name: DeleteCV :exec
DELETE FROM generated_cvs WHERE id = $1 AND user_id = $2
`

type DeleteCVParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID string      `json:"user_id"`
}

func (q *Queries) DeleteCV(ctx context.Context, arg DeleteCVParams) error {
	_, err := q.db.Exec(ctx, deleteCV, arg.ID, arg.UserID)
	return err
}

const deleteCoverLetter = `-- name: DeleteCoverLetter :exec
DELETE FROM cover_letters WHERE id = $1 AND user_id = $2
`

type DeleteCoverLetterParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID string      `json:"user_id"`
}

func (q *Queries) DeleteCoverLetter(ctx context.Context, arg DeleteCoverLetterParams) error {
	_, err := q.db.Exec(ctx, deleteCoverLetter, arg.ID, arg.UserID)
	return err
}

const deleteMasterProfile = `-- name: DeleteMasterProfile :exec
DELETE FROM master_profiles WHERE user_id = $1
`

func (q *Queries) DeleteMasterProfile(ctx context.Context, userID string) error {
	_, err := q.db.Exec(ctx, deleteMasterProfile, userID)
	return err
}

const getCV = `-- name: GetCV :one

SELECT id, user_id, name, job_url, job_title, company_name, job_description, cv_data, match_score, ai_suggestions, template_id, created_at, updated_at FROM generated_cvs WHERE id = $1 LIMIT 1
`

// ===================
// Generated CVs
// ===================
func (q *Queries) GetCV(ctx context.Context, id pgtype.UUID) (GeneratedCv, error) {
	row := q.db.QueryRow(ctx, getCV, id)
	var i GeneratedCv
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.JobUrl,
		&i.JobTitle,
		&i.CompanyName,
		&i.JobDescription,
		&i.CvData,
		&i.MatchScore,
		&i.AiSuggestions,
		&i.TemplateID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCVByUserAndId = `-- name: GetCVByUserAndId :one
SELECT id, user_id, name, job_url, job_title, company_name, job_description, cv_data, match_score, ai_suggestions, template_id, created_at, updated_at FROM generated_cvs WHERE id = $1 AND user_id = $2 LIMIT 1
`

type GetCVByUserAndIdParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID string      `json:"user_id"`
}

func (q *Queries) GetCVByUserAndId(ctx context.Context, arg GetCVByUserAndIdParams) (GeneratedCv, error) {
	row := q.db.QueryRow(ctx, getCVByUserAndId, arg.ID, arg.UserID)
	var i GeneratedCv
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.JobUrl,
		&i.JobTitle,
		&i.CompanyName,
		&i.JobDescription,
		&i.CvData,
		&i.MatchScore,
		&i.AiSuggestions,
		&i.TemplateID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCoverLetter = `-- name: GetCoverLetter :one

SELECT id, user_id, cv_id, content, job_title, company_name, created_at, updated_at FROM cover_letters WHERE id = $1 LIMIT 1
`

// ===================
// Cover Letters
// ===================
func (q *Queries) GetCoverLetter(ctx context.Context, id pgtype.UUID) (CoverLetter, error) {
	row := q.db.QueryRow(ctx, getCoverLetter, id)
	var i CoverLetter
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CvID,
		&i.Content,
		&i.JobTitle,
		&i.CompanyName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getCoverLetterByUserAndId = `-- name: GetCoverLetterByUserAndId :one
SELECT id, user_id, cv_id, content, job_title, company_name, created_at, updated_at FROM cover_letters WHERE id = $1 AND user_id = $2 LIMIT 1
`

type GetCoverLetterByUserAndIdParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID string      `json:"user_id"`
}

func (q *Queries) GetCoverLetterByUserAndId(ctx context.Context, arg GetCoverLetterByUserAndIdParams) (CoverLetter, error) {
	row := q.db.QueryRow(ctx, getCoverLetterByUserAndId, arg.ID, arg.UserID)
	var i CoverLetter
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CvID,
		&i.Content,
		&i.JobTitle,
		&i.CompanyName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getMasterProfile = `-- name: GetMasterProfile :one

SELECT id, user_id, resume_data, created_at, updated_at FROM master_profiles WHERE user_id = $1 LIMIT 1
`

// ===================
// Master Profiles
// ===================
func (q *Queries) GetMasterProfile(ctx context.Context, userID string) (MasterProfile, error) {
	row := q.db.QueryRow(ctx, getMasterProfile, userID)
	var i MasterProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ResumeData,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getOrCreateUserCredits = `-- name: GetOrCreateUserCredits :one
INSERT INTO user_credits (user_id, free_generations_used, free_generations_limit, paid_credits, total_generations)
VALUES ($1, 0, 10, 0, 0)
ON CONFLICT (user_id) DO UPDATE
SET updated_at = NOW()
RETURNING id, user_id, free_generations_used, free_generations_limit, created_at, updated_at, paid_credits, total_generations
`

func (q *Queries) GetOrCreateUserCredits(ctx context.Context, userID string) (UserCredit, error) {
	row := q.db.QueryRow(ctx, getOrCreateUserCredits, userID)
	var i UserCredit
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FreeGenerationsUsed,
		&i.FreeGenerationsLimit,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PaidCredits,
		&i.TotalGenerations,
	)
	return i, err
}

const getUserCredits = `-- name: GetUserCredits :one

SELECT id, user_id, free_generations_used, free_generations_limit, created_at, updated_at, paid_credits, total_generations FROM user_credits WHERE user_id = $1 LIMIT 1
`

// ===================
// User Credits
// ===================
func (q *Queries) GetUserCredits(ctx context.Context, userID string) (UserCredit, error) {
	row := q.db.QueryRow(ctx, getUserCredits, userID)
	var i UserCredit
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FreeGenerationsUsed,
		&i.FreeGenerationsLimit,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PaidCredits,
		&i.TotalGenerations,
	)
	return i, err
}

const incrementCreditsUsed = `-- name: IncrementCreditsUsed :one
UPDATE user_credits
SET 
    total_generations = total_generations + 1,
    free_generations_used = CASE 
        WHEN free_generations_used < free_generations_limit THEN free_generations_used + 1
        ELSE free_generations_used
    END,
    paid_credits = CASE 
        WHEN free_generations_used >= free_generations_limit THEN paid_credits - 1
        ELSE paid_credits
    END,
    updated_at = NOW()
WHERE user_id = $1
RETURNING id, user_id, free_generations_used, free_generations_limit, created_at, updated_at, paid_credits, total_generations
`

// Increments total_generations, uses free credits first, then paid credits
func (q *Queries) IncrementCreditsUsed(ctx context.Context, userID string) (UserCredit, error) {
	row := q.db.QueryRow(ctx, incrementCreditsUsed, userID)
	var i UserCredit
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FreeGenerationsUsed,
		&i.FreeGenerationsLimit,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PaidCredits,
		&i.TotalGenerations,
	)
	return i, err
}

const listCVsByUser = `-- name: ListCVsByUser :many
SELECT id, user_id, name, job_url, job_title, company_name, job_description, cv_data, match_score, ai_suggestions, template_id, created_at, updated_at FROM generated_cvs 
WHERE user_id = $1 
ORDER BY created_at DESC
`

func (q *Queries) ListCVsByUser(ctx context.Context, userID string) ([]GeneratedCv, error) {
	rows, err := q.db.Query(ctx, listCVsByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GeneratedCv{}
	for rows.Next() {
		var i GeneratedCv
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.JobUrl,
			&i.JobTitle,
			&i.CompanyName,
			&i.JobDescription,
			&i.CvData,
			&i.MatchScore,
			&i.AiSuggestions,
			&i.TemplateID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCVsByUserPaginated = `-- name: ListCVsByUserPaginated :many
SELECT id, user_id, name, job_url, job_title, company_name, job_description, cv_data, match_score, ai_suggestions, template_id, created_at, updated_at FROM generated_cvs 
WHERE user_id = $1 
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListCVsByUserPaginatedParams struct {
	UserID string `json:"user_id"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListCVsByUserPaginated(ctx context.Context, arg ListCVsByUserPaginatedParams) ([]GeneratedCv, error) {
	rows, err := q.db.Query(ctx, listCVsByUserPaginated, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []GeneratedCv{}
	for rows.Next() {
		var i GeneratedCv
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.JobUrl,
			&i.JobTitle,
			&i.CompanyName,
			&i.JobDescription,
			&i.CvData,
			&i.MatchScore,
			&i.AiSuggestions,
			&i.TemplateID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCoverLettersByCV = `-- name: ListCoverLettersByCV :many
SELECT id, user_id, cv_id, content, job_title, company_name, created_at, updated_at FROM cover_letters 
WHERE cv_id = $1 
ORDER BY created_at DESC
`

func (q *Queries) ListCoverLettersByCV(ctx context.Context, cvID pgtype.UUID) ([]CoverLetter, error) {
	rows, err := q.db.Query(ctx, listCoverLettersByCV, cvID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CoverLetter{}
	for rows.Next() {
		var i CoverLetter
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CvID,
			&i.Content,
			&i.JobTitle,
			&i.CompanyName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listCoverLettersByUser = `-- name: ListCoverLettersByUser :many
SELECT id, user_id, cv_id, content, job_title, company_name, created_at, updated_at FROM cover_letters 
WHERE user_id = $1 
ORDER BY created_at DESC
`

func (q *Queries) ListCoverLettersByUser(ctx context.Context, userID string) ([]CoverLetter, error) {
	rows, err := q.db.Query(ctx, listCoverLettersByUser, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []CoverLetter{}
	for rows.Next() {
		var i CoverLetter
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.CvID,
			&i.Content,
			&i.JobTitle,
			&i.CompanyName,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateCV = `-- name: UpdateCV :one
UPDATE generated_cvs
SET 
    name = COALESCE($3, name),
    cv_data = COALESCE($4, cv_data),
    template_id = COALESCE($5, template_id),
    updated_at = NOW()
WHERE id = $1 AND user_id = $2
RETURNING id, user_id, name, job_url, job_title, company_name, job_description, cv_data, match_score, ai_suggestions, template_id, created_at, updated_at
`

type UpdateCVParams struct {
	ID         pgtype.UUID `json:"id"`
	UserID     string      `json:"user_id"`
	Name       pgtype.Text `json:"name"`
	CvData     []byte      `json:"cv_data"`
	TemplateID pgtype.Text `json:"template_id"`
}

func (q *Queries) UpdateCV(ctx context.Context, arg UpdateCVParams) (GeneratedCv, error) {
	row := q.db.QueryRow(ctx, updateCV,
		arg.ID,
		arg.UserID,
		arg.Name,
		arg.CvData,
		arg.TemplateID,
	)
	var i GeneratedCv
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.JobUrl,
		&i.JobTitle,
		&i.CompanyName,
		&i.JobDescription,
		&i.CvData,
		&i.MatchScore,
		&i.AiSuggestions,
		&i.TemplateID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCVName = `-- name: UpdateCVName :one
UPDATE generated_cvs
SET name = $3, updated_at = NOW()
WHERE id = $1 AND user_id = $2
RETURNING id, user_id, name, job_url, job_title, company_name, job_description, cv_data, match_score, ai_suggestions, template_id, created_at, updated_at
`

type UpdateCVNameParams struct {
	ID     pgtype.UUID `json:"id"`
	UserID string      `json:"user_id"`
	Name   string      `json:"name"`
}

func (q *Queries) UpdateCVName(ctx context.Context, arg UpdateCVNameParams) (GeneratedCv, error) {
	row := q.db.QueryRow(ctx, updateCVName, arg.ID, arg.UserID, arg.Name)
	var i GeneratedCv
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.JobUrl,
		&i.JobTitle,
		&i.CompanyName,
		&i.JobDescription,
		&i.CvData,
		&i.MatchScore,
		&i.AiSuggestions,
		&i.TemplateID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateCoverLetter = `-- name: UpdateCoverLetter :one
UPDATE cover_letters
SET content = $3, updated_at = NOW()
WHERE id = $1 AND user_id = $2
RETURNING id, user_id, cv_id, content, job_title, company_name, created_at, updated_at
`

type UpdateCoverLetterParams struct {
	ID      pgtype.UUID `json:"id"`
	UserID  string      `json:"user_id"`
	Content string      `json:"content"`
}

func (q *Queries) UpdateCoverLetter(ctx context.Context, arg UpdateCoverLetterParams) (CoverLetter, error) {
	row := q.db.QueryRow(ctx, updateCoverLetter, arg.ID, arg.UserID, arg.Content)
	var i CoverLetter
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.CvID,
		&i.Content,
		&i.JobTitle,
		&i.CompanyName,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateMasterProfile = `-- name: UpdateMasterProfile :one
UPDATE master_profiles
SET resume_data = $2, updated_at = NOW()
WHERE user_id = $1
RETURNING id, user_id, resume_data, created_at, updated_at
`

type UpdateMasterProfileParams struct {
	UserID     string `json:"user_id"`
	ResumeData []byte `json:"resume_data"`
}

func (q *Queries) UpdateMasterProfile(ctx context.Context, arg UpdateMasterProfileParams) (MasterProfile, error) {
	row := q.db.QueryRow(ctx, updateMasterProfile, arg.UserID, arg.ResumeData)
	var i MasterProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ResumeData,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertMasterProfile = `-- name: UpsertMasterProfile :one
INSERT INTO master_profiles (user_id, resume_data)
VALUES ($1, $2)
ON CONFLICT (user_id) DO UPDATE
SET resume_data = EXCLUDED.resume_data, updated_at = NOW()
RETURNING id, user_id, resume_data, created_at, updated_at
`

type UpsertMasterProfileParams struct {
	UserID     string `json:"user_id"`
	ResumeData []byte `json:"resume_data"`
}

func (q *Queries) UpsertMasterProfile(ctx context.Context, arg UpsertMasterProfileParams) (MasterProfile, error) {
	row := q.db.QueryRow(ctx, upsertMasterProfile, arg.UserID, arg.ResumeData)
	var i MasterProfile
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.ResumeData,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
